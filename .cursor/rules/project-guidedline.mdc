---
alwaysApply: true
---

## 프로젝트 개요
이 프로젝트는 Flutter 기반의 크로스 플랫폼 모바일 애플리케이션입니다.
현대적인 아키텍처 패턴과 Clean Code 원칙을 따르며, 확장 가능하고 유지보수가 용이한 구조를 목표로 합니다.

## 프로젝트 구조

### 주요 디렉토리 설명
- `clients/`: 외부 서비스와의 통신을 담당하는 클라이언트 모듈
- `models/`: 앱에서 사용하는 데이터 구조 정의
- `screens/`: 앱의 각 화면을 구성하는 위젯
- `services/`: 비즈니스 로직을 처리하는 계층
- `states/`: 앱의 상태 관리 로직
- `theme/`: 앱의 디자인 시스템 정의
- `utils/`: 유틸리티 함수 모음
- `widgets/`: 여러 화면에서 재사용되는 공통 위젯

## 사용 중인 주요 패키지

### 핵심 패키지
- `go_router: ^12.1.3`: Flutter 애플리케이션의 라우팅을 관리하는 패키지
- `provider: ^6.1.2`: 상태 관리를 위한 패키지
- `flutter_dotenv: ^5.2.1`: .env 파일에서 환경 변수를 로드하는 패키지

### UI/UX 패키지
- `cupertino_icons: ^1.0.8`: iOS 스타일의 아이콘을 제공하는 패키지
- `google_fonts: ^6.1.0`: Google Fonts를 Flutter 애플리케이션에서 사용할 수 있게 해주는 패키지
- `flutter_native_splash: ^2.3.13`: 앱 시작 시 네이티브 스플래시 화면을 추가하는 패키지

### 기능 패키지
- `permission_handler: ^11.3.0`: 앱의 권한을 관리하는 패키지
- `intl: ^0.19.0`: 국제화 및 지역화 지원을 위한 패키지

## 코딩 규칙 및 가이드라인

### 1. 파일 및 디렉토리 구조
- 모든 Dart 파일은 `lib/` 디렉토리 내에 적절한 하위 디렉토리에 위치
- 파일명은 snake_case 사용 (예: `home_screen.dart`, `user_service.dart`)
- 클래스명은 PascalCase 사용 (예: `HomeScreen`, `UserService`)
- 상수는 UPPER_SNAKE_CASE 사용 (예: `MAX_RETRY_COUNT`, `API_BASE_URL`)

### 2. 상태 관리 (Provider 패턴)
- 상태 관리는 Provider 패턴을 사용
- `states/` 디렉토리에 상태 관리 클래스 배치
- ChangeNotifier를 상속받아 상태 클래스 구현
- 상태 변경 시 `notifyListeners()` 호출 필수

### 3. 라우팅 (GoRouter)
- 모든 라우팅은 `router.dart`에서 중앙 관리
- 라우트 경로는 kebab-case 사용 (예: `/user-profile`, `/settings`)
- 라우트 파라미터는 명확한 이름 사용 (예: `/user/:userId`)

### 4. 환경 변수 관리
- `.env` 파일을 사용하여 환경별 설정 관리
- `flutter_dotenv` 패키지를 통해 환경 변수 로드
- 민감한 정보는 절대 코드에 하드코딩하지 않음

### 5. 위젯 구조
- 화면별 위젯은 `screens/` 디렉토리에 배치
- 재사용 가능한 위젯은 `widgets/` 디렉토리에 배치
- 위젯은 단일 책임 원칙을 따름
- 복잡한 위젯은 작은 단위로 분리

### 6. 서비스 계층
- 비즈니스 로직은 `services/` 디렉토리에 배치
- 외부 API 통신은 `clients/` 디렉토리에 배치
- 서비스 클래스는 싱글톤 패턴 또는 의존성 주입 사용

### 7. 데이터 모델
- 데이터 구조는 `models/` 디렉토리에 배치
- JSON 직렬화/역직렬화를 위한 `fromJson`, `toJson` 메서드 구현
- 불변 객체 사용 권장

### 8. 테마 및 디자인
- 테마 설정은 `theme/` 디렉토리에 중앙화
- Google Fonts를 활용한 일관된 타이포그래피
- Material Design 3 가이드라인 준수
- 다크 모드 지원 고려

### 9. 국제화 (i18n)
- `intl` 패키지를 사용한 다국어 지원
- 모든 사용자 대면 텍스트는 다국어 지원 고려
- 언어별 리소스 파일은 `lib/l10n/` 디렉토리에 배치

### 10. 권한 관리
- `permission_handler` 패키지를 사용한 권한 관리
- 권한 요청은 사용자 경험을 고려한 적절한 시점에 수행
- 권한 거부 시 대안 제공

## 코드 품질 규칙

### 1. 네이밍 컨벤션
- 변수명: camelCase (예: `userName`, `isLoading`)
- 함수명: camelCase (예: `fetchUserData`, `validateInput`)
- 클래스명: PascalCase (예: `UserService`, `HomeScreen`)
- 상수명: UPPER_SNAKE_CASE (예: `API_TIMEOUT`, `MAX_RETRY_COUNT`)

### 2. 주석 및 문서화
- 공개 API는 반드시 문서화 주석 작성
- 복잡한 비즈니스 로직은 인라인 주석으로 설명
- TODO 주석은 반드시 담당자와 마감일 명시

### 3. 에러 처리
- 모든 비동기 작업에 적절한 에러 처리 구현
- 사용자 친화적인 에러 메시지 제공
- 로깅을 통한 디버깅 정보 수집

### 4. 성능 최적화
- 불필요한 위젯 리빌드 방지
- 이미지 최적화 및 캐싱 활용
- 메모리 누수 방지를 위한 적절한 리소스 해제

### 5. 테스트
- 단위 테스트는 `test/` 디렉토리에 배치
- 위젯 테스트는 `test/widget_test/` 디렉토리에 배치
- 테스트 커버리지 80% 이상 유지 목표

## 개발 워크플로우

### 1. 브랜치 전략
- `main`: 프로덕션 배포용 브랜치
- `develop`: 개발 통합 브랜치
- `feature/*`: 기능 개발 브랜치
- `hotfix/*`: 긴급 수정 브랜치

### 2. 커밋 메시지 규칙
- 형식: `type(scope): description`
- 타입: feat, fix, docs, style, refactor, test, chore
- 예시: `feat(auth): add login functionality`

### 3. 코드 리뷰
- 모든 변경사항은 코드 리뷰 필수
- 최소 1명 이상의 승인 후 머지
- 자동화된 테스트 통과 후 머지

## 보안 가이드라인

### 1. 민감한 정보 보호
- API 키, 토큰 등은 환경 변수로 관리
- 버전 관리 시스템에 민감한 정보 커밋 금지
- 프로덕션 환경과 개발 환경 분리

### 2. 데이터 보안
- 사용자 데이터 암호화 저장
- 네트워크 통신 시 HTTPS 사용
- 적절한 권한 검증 구현

## 성능 모니터링

### 1. 앱 성능
- 앱 시작 시간 최적화
- 메모리 사용량 모니터링
- 배터리 소모 최적화

### 2. 사용자 경험
- 로딩 상태 적절히 표시
- 오프라인 상태 처리
- 접근성 가이드라인 준수

## 배포 및 릴리스

### 1. 빌드 설정
- 프로덕션 빌드 시 최적화 옵션 활성화
- 코드 난독화 및 최소화 적용
- 적절한 버전 관리

### 2. 플랫폼별 고려사항
- iOS: App Store 가이드라인 준수
- Android: Google Play 정책 준수
- 웹: PWA 기능 활용

## 문제 해결 및 디버깅

### 1. 로깅 전략
- 개발 환경: 상세한 디버그 로그
- 프로덕션 환경: 필수 정보만 로깅
- 로그 레벨별 적절한 분류

### 2. 에러 추적
- 크래시 리포팅 도구 활용
- 사용자 피드백 수집 시스템
- 성능 모니터링 도구 연동

---

이 룰 문서는 프로젝트의 일관성과 품질을 유지하기 위한 가이드라인입니다.
모든 팀원은 이 규칙을 준수하여 개발에 참여해야 합니다.